import { sql } from "drizzle-orm";
import { pgTable, text, varchar, timestamp, integer, index, jsonb } from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";

// Session storage table (Required for Replit Auth)
export const sessions = pgTable(
  "sessions",
  {
    sid: varchar("sid").primaryKey(),
    sess: jsonb("sess").notNull(),
    expire: timestamp("expire").notNull(),
  },
  (table) => [index("IDX_session_expire").on(table.expire)],
);

// User storage table (Supports both Replit Auth and local password auth)
export const users = pgTable("users", {
  id: varchar("id").primaryKey(), // Short ID generated by nanoid(10) for local users, Replit ID for OIDC users
  email: varchar("email").unique(),
  username: varchar("username").unique(),
  passwordHash: varchar("password_hash"), // bcrypt hash (includes salt)
  verifiedAt: timestamp("verified_at"), // email verification timestamp
  resetToken: varchar("reset_token"), // password reset token
  resetTokenExpiry: timestamp("reset_token_expiry"), // when reset token expires
  firstName: varchar("first_name"),
  lastName: varchar("last_name"),
  profileImageUrl: varchar("profile_image_url"),
  stripeCustomerId: varchar("stripe_customer_id"),
  stripeSubscriptionId: varchar("stripe_subscription_id"),
  membershipTier: varchar("membership_tier", { length: 20 }).default("free").notNull(),
  videosGeneratedThisMonth: integer("videos_generated_this_month").default(0).notNull(),
  lastResetDate: timestamp("last_reset_date").defaultNow().notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export type UpsertUser = typeof users.$inferInsert;
export type User = typeof users.$inferSelect;

// Frontend user object with computed fields (doesn't expose sensitive fields)
export type FrontendUser = Omit<User, 'passwordHash' | 'resetToken' | 'resetTokenExpiry'> & {
  hasPassword: boolean; // Computed from passwordHash existence
};

// Subscription plans configuration
export const MEMBERSHIP_TIERS = {
  free: {
    name: "Free",
    price: 0,
    monthlyVideos: 5,
    maxLength: 10,
    quality: "basic",
  },
  pro: {
    name: "Pro",
    price: 19,
    monthlyVideos: 50,
    maxLength: 15,
    quality: "hd",
    get stripePriceId() {
      return process.env.STRIPE_PRICE_ID_PRO?.trim() || null;
    },
  },
  premium: {
    name: "Premium",
    price: 49,
    monthlyVideos: -1, // unlimited
    maxLength: 15,
    quality: "4k",
    get stripePriceId() {
      return process.env.STRIPE_PRICE_ID_PREMIUM?.trim() || null;
    },
  },
} as const;

export type MembershipTier = keyof typeof MEMBERSHIP_TIERS;

// Video generation history table
export const videoGenerations = pgTable("video_generations", {
  id: integer("id").primaryKey().generatedAlwaysAsIdentity(),
  userId: varchar("user_id").references(() => users.id),
  prompt: text("prompt").notNull(),
  videoUrl: text("video_url").notNull(),
  length: integer("length").default(10),
  aspectRatio: varchar("aspect_ratio", { length: 10 }).default("1:1"),
  style: text("style"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

export const insertVideoGenerationSchema = createInsertSchema(videoGenerations).pick({
  prompt: true,
  videoUrl: true,
  length: true,
  aspectRatio: true,
  style: true,
});

export type InsertVideoGeneration = typeof videoGenerations.$inferInsert;
export type VideoGeneration = typeof videoGenerations.$inferSelect;

// User settings table
export const userSettings = pgTable("user_settings", {
  id: integer("id").primaryKey().generatedAlwaysAsIdentity(),
  userId: varchar("user_id").references(() => users.id).unique().notNull(),
  defaultLength: integer("default_length").default(10).notNull(),
  defaultAspectRatio: varchar("default_aspect_ratio", { length: 10 }).default("1:1").notNull(),
  emailNotifications: integer("email_notifications").default(1).notNull(), // 1 = enabled, 0 = disabled
  galleryView: varchar("gallery_view", { length: 10 }).default("grid").notNull(),
  theme: varchar("theme", { length: 10 }).default("dark").notNull(),
  autoSave: integer("auto_save").default(1).notNull(), // 1 = enabled, 0 = disabled
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const insertUserSettingsSchema = createInsertSchema(userSettings);

export const updateUserSettingsSchema = insertUserSettingsSchema.partial().omit({ userId: true });

export type InsertUserSettings = z.infer<typeof insertUserSettingsSchema>;
export type UpdateUserSettings = z.infer<typeof updateUserSettingsSchema>;
export type UserSettings = typeof userSettings.$inferSelect;

// Video generation request schema
export const videoGenerationSchema = z.object({
  prompt: z.string().min(1, "Prompt is required").max(500, "Prompt must be less than 500 characters"),
  length: z.number().refine((val) => [5, 10, 15].includes(val), "Length must be 5, 10, or 15 seconds").default(10),
  aspectRatio: z.enum(["1:1", "16:9", "9:16"]).default("1:1"),
  style: z.string().optional(),
});

export type VideoGenerationRequest = z.infer<typeof videoGenerationSchema>;

// Video generation response schema
export interface VideoGenerationResponse {
  videoUrl: string;
  prompt: string;
  id?: number;
}

// Error response schema
export interface ErrorResponse {
  error: string;
  message?: string;
}

// Authentication schemas
export const registerSchema = z.object({
  email: z.string().email("Invalid email address"),
  username: z.string()
    .min(3, "Username must be at least 3 characters")
    .max(20, "Username must be less than 20 characters")
    .regex(/^[a-zA-Z0-9_]+$/, "Username can only contain letters, numbers, and underscores"),
  password: z.string()
    .min(8, "Password must be at least 8 characters")
    .regex(/[A-Z]/, "Password must contain at least one uppercase letter")
    .regex(/[a-z]/, "Password must contain at least one lowercase letter")
    .regex(/[0-9]/, "Password must contain at least one number"),
  firstName: z.string().min(1, "First name is required").optional(),
  lastName: z.string().min(1, "Last name is required").optional(),
});

export const loginSchema = z.object({
  usernameOrEmail: z.string().min(1, "Username or email is required"),
  password: z.string().min(1, "Password is required"),
});

export type RegisterRequest = z.infer<typeof registerSchema>;
export type LoginRequest = z.infer<typeof loginSchema>;

// Account audit log table - tracks account creation and deletion
// NOTE: userId is NOT a foreign key - it's an immutable record that persists after user deletion
export const accountAuditLog = pgTable("account_audit_log", {
  id: integer("id").primaryKey().generatedAlwaysAsIdentity(),
  userId: varchar("user_id").notNull(), // Stored as plain text, not a foreign key reference
  email: varchar("email").notNull(),
  username: varchar("username"),
  action: varchar("action", { length: 20 }).notNull(), // "created" or "deleted"
  authProvider: varchar("auth_provider", { length: 20 }).notNull(), // "local" or "replit"
  metadata: jsonb("metadata"), // Additional data like IP, user agent, etc.
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

export type AccountAuditLog = typeof accountAuditLog.$inferSelect;
export type InsertAccountAuditLog = typeof accountAuditLog.$inferInsert;
